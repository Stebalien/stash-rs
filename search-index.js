var searchIndex = {};
searchIndex["stash"] = {"doc":"","items":[[0,"stash","stash","",null,null],[3,"ExtendIndices","stash::stash","",null,null],[3,"Iter","","Iterator over the `(index, &amp;value)` pairs.",null,null],[3,"IterMut","","Iterator over the `(index, &amp;mut value)` pairs.",null,null],[3,"IntoIter","","Iterator over the `(index, value)` pairs.",null,null],[3,"Values","","Iterator over references to the values in the stash.",null,null],[3,"ValuesMut","","Iterator over mutable references to the values in the stash.",null,null],[3,"IntoValues","","Iterator over values in the stash.",null,null],[3,"Stash","","A `Stash` is a place to put items where you need (amortized) `O(1)`\ninsertion, deletion, and lookups but don&#39;t care about the order of the\nitems, don&#39;t need to be able to choose the keys, and don&#39;t want to pay the\noverhead of hashing.",null,null],[11,"drop","","",0,null],[11,"next","","",0,null],[11,"size_hint","","",0,null],[11,"next_back","","",0,null],[11,"next","","",1,null],[11,"size_hint","","",1,null],[11,"len","","",1,null],[11,"next_back","","",1,null],[11,"next","","",2,null],[11,"size_hint","","",2,null],[11,"len","","",2,null],[11,"next_back","","",2,null],[11,"next","","",3,null],[11,"size_hint","","",3,null],[11,"len","","",3,null],[11,"next_back","","",3,null],[11,"next","","",4,null],[11,"size_hint","","",4,null],[11,"len","","",4,null],[11,"next_back","","",4,null],[11,"next","","",5,null],[11,"size_hint","","",5,null],[11,"len","","",5,null],[11,"next_back","","",5,null],[11,"next","","",6,null],[11,"size_hint","","",6,null],[11,"len","","",6,null],[11,"next_back","","",6,null],[11,"clone","","",7,null],[11,"new","","Constructs a new, empty `Stash&lt;T&gt;`.",7,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Constructs a new, empty `Stash&lt;T&gt;` with the specified capacity.",7,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"capacity","","Returns the number of elements the stash can hold without reallocating.",7,null],[11,"len","","The number of items in the stash.",7,null],[11,"reserve","","Reserves capacity for at least `additional` more elements to be put into\nthe given `Stash&lt;T&gt;`. The collection may reserve more space to avoid\nfrequent reallocations.",7,null],[11,"reserve_exact","","Reserves the minimum capacity for exactly `additional` more elements to\nbe put into the given `Stash&lt;T&gt;`. Does nothing if the capacity is already\nsufficient.",7,null],[11,"put","","Put a value into the stash.",7,null],[11,"extend","","Put all items in the iterator into the stash.",7,null],[11,"iter","","Iterate over the items in this `Stash&lt;V&gt;`.",7,null],[11,"iter_mut","","Mutably iterate over the items in this `Stash&lt;V&gt;`.",7,null],[11,"values","","Iterate over the values in this `Stash&lt;V&gt;` by reference.",7,null],[11,"values_mut","","Mutably iterate over the values in this `Stash&lt;V&gt;` by reference.",7,null],[11,"into_values","","Iterate over the values in this `Stash&lt;V&gt;` by value.",7,null],[11,"is_empty","","Check if this `Stash&lt;V&gt;` is empty.",7,null],[11,"take","","Take an item from a slot (if non empty).",7,null],[11,"get","","Get a reference to the value at `index`.",7,null],[11,"get_mut","","Get a mutable reference to the value at `index`.",7,null],[11,"clear","","Clear the stash",7,null],[11,"into_iter","","",7,null],[11,"fmt","","",7,null],[11,"index","","",7,null],[11,"index_mut","","",7,null],[11,"default","","",7,{"inputs":[],"output":{"name":"self"}}],[0,"unique_stash","stash","",null,null],[3,"Tag","stash::unique_stash","A versioned index into a `UniqueStash`. No two calls to `put` on the same\n`UniqueStash` will ever return the same `Tag`.",null,null],[3,"Extend","","The iterator produced by `Unique::extend`.",null,null],[3,"Iter","","Iterator over the `(index, &amp;value)` pairs.",null,null],[3,"IterMut","","Iterator over the `(index, &amp;mut value)` pairs.",null,null],[3,"IntoIter","","Iterator over the `(index, value)` pairs.",null,null],[3,"Values","","Iterator over references to the values in the stash.",null,null],[3,"ValuesMut","","Iterator over mutable references to the values in the stash.",null,null],[3,"IntoValues","","Iterator over values in the stash.",null,null],[3,"UniqueStash","","A `UniqueStash` is a place to put items where you need (amortized) `O(1)`\ninsertion, deletion, and lookups but don&#39;t care about the order of the\nitems, don&#39;t need to be able to choose the keys, don&#39;t want to pay the\noverhead of hashing, and can&#39;t handle key reuse.",null,null],[11,"hash","","",8,null],[11,"partial_cmp","","",8,null],[11,"lt","","",8,null],[11,"le","","",8,null],[11,"gt","","",8,null],[11,"ge","","",8,null],[11,"cmp","","",8,null],[11,"eq","","",8,null],[11,"ne","","",8,null],[11,"clone","","",8,null],[11,"fmt","","",8,null],[11,"fmt","","",8,null],[11,"drop","","",9,null],[11,"next","","",9,null],[11,"size_hint","","",9,null],[11,"next_back","","",9,null],[11,"next","","",10,null],[11,"size_hint","","",10,null],[11,"len","","",10,null],[11,"next_back","","",10,null],[11,"next","","",11,null],[11,"size_hint","","",11,null],[11,"len","","",11,null],[11,"next_back","","",11,null],[11,"next","","",12,null],[11,"size_hint","","",12,null],[11,"len","","",12,null],[11,"next_back","","",12,null],[11,"next","","",13,null],[11,"size_hint","","",13,null],[11,"len","","",13,null],[11,"next_back","","",13,null],[11,"next","","",14,null],[11,"size_hint","","",14,null],[11,"len","","",14,null],[11,"next_back","","",14,null],[11,"next","","",15,null],[11,"size_hint","","",15,null],[11,"len","","",15,null],[11,"next_back","","",15,null],[11,"clone","","",16,null],[11,"new","","Constructs a new, empty `UniqueStash&lt;T&gt;`.",16,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Constructs a new, empty `UniqueStash&lt;T&gt;` with the specified capacity.",16,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"capacity","","Returns the number of elements the stash can hold without reallocating.",16,null],[11,"len","","The number of items in the stash.",16,null],[11,"reserve","","Reserves capacity for at least `additional` more elements to be put into\nthe given `UniqueStash&lt;T&gt;`. The collection may reserve more space to avoid\nfrequent reallocations.",16,null],[11,"reserve_exact","","Reserves the minimum capacity for exactly `additional` more elements to\nbe put into the given `UniqueStash&lt;T&gt;`. Does nothing if the capacity is already\nsufficient.",16,null],[11,"put","","Put a value into the stash.",16,null],[11,"extend","","Put all items in the iterator into the stash.",16,null],[11,"iter","","Iterate over the items in this `UniqueStash&lt;V&gt;`.",16,null],[11,"iter_mut","","Mutably iterate over the items in this `UniqueStash&lt;V&gt;`.",16,null],[11,"values","","Iterate over the values in this `UniqueStash&lt;V&gt;` by reference.",16,null],[11,"values_mut","","Mutably iterate over the values in this `UniqueStash&lt;V&gt;` by reference.",16,null],[11,"into_values","","Iterate over the values in this `UniqueStash&lt;V&gt;` by value.",16,null],[11,"is_empty","","Check if this `UniqueStash&lt;V&gt;` is empty.",16,null],[11,"take","","Take an item from a slot (if non empty).",16,null],[11,"get","","Get a reference to the value at `index`.",16,null],[11,"get_mut","","Get a mutable reference to the value at `index`.",16,null],[11,"clear","","Clear the UniqueStash.",16,null],[11,"into_iter","","",16,null],[11,"fmt","","",16,null],[11,"index","","",16,null],[11,"index_mut","","",16,null],[11,"default","","",16,{"inputs":[],"output":{"name":"self"}}]],"paths":[[3,"ExtendIndices"],[3,"Values"],[3,"ValuesMut"],[3,"IntoValues"],[3,"Iter"],[3,"IterMut"],[3,"IntoIter"],[3,"Stash"],[3,"Tag"],[3,"Extend"],[3,"Values"],[3,"ValuesMut"],[3,"IntoValues"],[3,"Iter"],[3,"IterMut"],[3,"IntoIter"],[3,"UniqueStash"]]};
searchIndex["bag"] = {"doc":"","items":[[3,"Indices","bag","",null,null],[3,"Iter","","",null,null],[3,"IterMut","","",null,null],[3,"IntoIter","","",null,null],[3,"Bag","","A data structure storing values indexed by tickets.",null,null],[11,"drop","","",0,null],[11,"next","","",0,null],[11,"size_hint","","",0,null],[11,"next_back","","",0,null],[11,"next","","",1,null],[11,"size_hint","","",1,null],[11,"len","","",1,null],[11,"next_back","","",1,null],[11,"next","","",2,null],[11,"size_hint","","",2,null],[11,"len","","",2,null],[11,"next_back","","",2,null],[11,"next","","",3,null],[11,"size_hint","","",3,null],[11,"len","","",3,null],[11,"next_back","","",3,null],[11,"clone","","",4,null],[11,"new","","Constructs a new, empty `Bag&lt;T&gt;`.",4,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Constructs a new, empty `Bag&lt;T&gt;` with the specified capacity.",4,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"capacity","","Returns the number of elements the bag can hold without reallocating.",4,null],[11,"len","","The number of items in the bag.",4,null],[11,"reserve","","Reserves capacity for at least `additional` more elements to be put into\nthe given `Bag&lt;T&gt;`. The collection may reserve more space to avoid\nfrequent reallocations.",4,null],[11,"reserve_exact","","Reserves the minimum capacity for exactly `additional` more elements to\nbe put into the given `Bag&lt;T&gt;`. Does nothing if the capacity is already\nsufficient.",4,null],[11,"put","","Put a value into the bag.",4,null],[11,"extend","","Put all items in the iterator into the bag.",4,null],[11,"iter","","Iterate over the items in this `Bag&lt;V&gt;`.",4,null],[11,"iter_mut","","Mutably iterate over the items in this `Bag&lt;V&gt;`.",4,null],[11,"is_empty","","Check if this `Bag&lt;V&gt;` is empty.",4,null],[11,"take","","Take an item from a slot (if non empty).",4,null],[11,"get","","Get a reference to the value at `index`.",4,null],[11,"get_mut","","Get a mutable reference to the value at `index`.",4,null],[11,"into_iter","","",4,null],[11,"fmt","","",4,null],[11,"index","","",4,null],[11,"index_mut","","",4,null],[11,"default","","",4,{"inputs":[],"output":{"name":"self"}}]],"paths":[[3,"Indices"],[3,"Iter"],[3,"IterMut"],[3,"IntoIter"],[3,"Bag"]]};
searchIndex['coatcheck'] = {"items":[[0,"","coatcheck","# CoatCheck",null,null],[3,"Ticket","","A `Ticket` is an opaque data structure that can be used to claim the associated value.",null,null],[3,"ClaimError","","The error yielded when a claim fails.",null,null],[12,"kind","","The error kind.",0,null],[12,"ticket","","The ticket used in the failed claim.",0,null],[3,"AccessError","","The error yielded an access fails.",null,null],[12,"kind","","The error kind.",1,null],[3,"Tickets","","Iterator that checks-in values in exchange for tickets.",null,null],[3,"CoatCheck","","A data structure storing values indexed by tickets.",null,null],[4,"ErrorKind","","Coat check error types",null,null],[13,"WrongCoatCheck","","",2,null],[11,"fmt","","",3,{"inputs":[{"name":"ticket"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"errorkind"}],"output":{"name":"errorkind"}}],[11,"description","","",2,{"inputs":[{"name":"errorkind"}],"output":{"name":"str"}}],[11,"description","","",0,{"inputs":[{"name":"claimerror"}],"output":{"name":"str"}}],[11,"fmt","","",0,{"inputs":[{"name":"claimerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"claimerror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"from","","",3,{"inputs":[{"name":"ticket"},{"name":"claimerror"}],"output":{"name":"ticket"}}],[11,"clone","","",1,{"inputs":[{"name":"accesserror"}],"output":{"name":"accesserror"}}],[11,"description","","",1,{"inputs":[{"name":"accesserror"}],"output":{"name":"str"}}],[11,"fmt","","",1,{"inputs":[{"name":"accesserror"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",1,{"inputs":[{"name":"accesserror"},{"name":"formatter"}],"output":{"name":"result"}}],[6,"Item","","",null,null],[11,"next","","",4,{"inputs":[{"name":"tickets"}],"output":{"name":"option"}}],[11,"size_hint","","",4,null],[11,"next_back","","",4,{"inputs":[{"name":"tickets"}],"output":{"name":"option"}}],[11,"new","","Constructs a new, empty `CoatCheck<T>`.",5,{"inputs":[{"name":"coatcheck"}],"output":{"name":"self"}}],[11,"with_capacity","","Constructs a new, empty `CoatCheck<T>` with the specified capacity.",5,{"inputs":[{"name":"coatcheck"},{"name":"usize"}],"output":{"name":"self"}}],[11,"capacity","","Returns the number of elements the coat check can hold without reallocating.",5,{"inputs":[{"name":"coatcheck"}],"output":{"name":"usize"}}],[11,"len","","The number of checked items.",5,{"inputs":[{"name":"coatcheck"}],"output":{"name":"usize"}}],[11,"reserve","","Reserves capacity for at least `additional` more elements to be checked into the given\n`CoatCheck<T>`. The collection may reserve more space to avoid frequent reallocations.",5,{"inputs":[{"name":"coatcheck"},{"name":"usize"}],"output":null}],[11,"reserve_exact","","Reserves the minimum capacity for exactly `additional` more elements to be check into the\ngiven `CoatCheck<T>`. Does nothing if the capacity is already sufficient.",5,{"inputs":[{"name":"coatcheck"},{"name":"usize"}],"output":null}],[11,"check","","Check a value in and get a `Ticket `in exchange.",5,{"inputs":[{"name":"coatcheck"},{"name":"v"}],"output":{"name":"ticket"}}],[11,"check_all","","Check all the items in an iterator and get tickets back.",5,{"inputs":[{"name":"coatcheck"},{"name":"i"}],"output":{"name":"tickets"}}],[11,"iter","","Iterate over the items in this `CoatCheck<V>`.",5,{"inputs":[{"name":"coatcheck"}],"output":{"name":"iter"}}],[11,"iter_mut","","Mutably iterate over the items in this `CoatCheck<V>`.",5,{"inputs":[{"name":"coatcheck"}],"output":{"name":"itermut"}}],[11,"contains_ticket","","Check if a ticket belongs to this `CoatCheck<V>`.",5,{"inputs":[{"name":"coatcheck"},{"name":"ticket"}],"output":{"name":"bool"}}],[11,"is_empty","","Check if this `CoatCheck<V>` is empty.",5,{"inputs":[{"name":"coatcheck"}],"output":{"name":"bool"}}],[11,"claim","","Claim an item.",5,{"inputs":[{"name":"coatcheck"},{"name":"ticket"}],"output":{"name":"result"}}],[11,"get","","Get a reference to the value matching this ticket.",5,{"inputs":[{"name":"coatcheck"},{"name":"ticket"}],"output":{"name":"result"}}],[11,"get_mut","","Get a mutable reference to the value matching this ticket.",5,{"inputs":[{"name":"coatcheck"},{"name":"ticket"}],"output":{"name":"result"}}],[6,"Item","","",null,null],[6,"IntoIter","","",null,null],[11,"into_iter","","Creates a consuming iterator, that is, one that moves each value out of the coat check (from\nstart to end). The coat check cannot be used after calling this.",5,{"inputs":[{"name":"coatcheck"}],"output":{"name":"intoiter"}}],[11,"fmt","","",5,{"inputs":[{"name":"coatcheck"},{"name":"formatter"}],"output":{"name":"result"}}],[6,"Output","","",null,null],[11,"index","","",5,{"inputs":[{"name":"coatcheck"},{"name":"ticket"}],"output":{"name":"v"}}],[11,"index_mut","","",5,{"inputs":[{"name":"coatcheck"},{"name":"ticket"}],"output":{"name":"v"}}],[11,"default","","",5,{"inputs":[{"name":"coatcheck"}],"output":{"name":"self"}}]],"paths":[[3,"ClaimError"],[3,"AccessError"],[4,"ErrorKind"],[3,"Ticket"],[3,"Tickets"],[3,"CoatCheck"]]};
searchIndex['snowflake'] = {"items":[[0,"","snowflake","A crate for quickly generating unique IDs with guaranteed properties.",null,null],[3,"ProcessUniqueId","","Process unique IDs are guaranteed to be unique within the current process, for the lifetime of\nthe current process.",null,null],[11,"eq","","",0,{"inputs":[{"name":"processuniqueid"},{"name":"processuniqueid"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"processuniqueid"},{"name":"processuniqueid"}],"output":{"name":"bool"}}],[11,"clone","","",0,{"inputs":[{"name":"processuniqueid"}],"output":{"name":"processuniqueid"}}],[11,"new","","Create a new unique ID.",0,{"inputs":[{"name":"processuniqueid"}],"output":{"name":"self"}}],[11,"default","","",0,{"inputs":[{"name":"processuniqueid"}],"output":{"name":"self"}}]],"paths":[[3,"ProcessUniqueId"]]};
initSearch(searchIndex);
